

# Что нужно сделать для 20 баллов?

Реализуйте три класса используя **динамические массивы** и **индексы**:

1. **`Queue`** — очередь
2. **`Deque`** — двусторонняя очередь 
3. **`BinarySearchTree`** — бинарное дерево поиска 


##  `Queue` 

```cpp
#include <iostream>
#include <stdexcept>
#include <cstddef>

const size_t INITIAL_CAPACITY = 4;

class Queue {
private:
     // Динамический массив для хранения элементов
    // Индекс первого элемента
    // Индекс, куда будет добавлен следующий элемент
    // Текущее количество элементов
    // Вместимость массива

   
public:
    // Конструктор
    Queue() {
    // - data - новый массив из 4 целых чисел.
    // - frontIndex и backIndex оба равные 0 — очередь пуста
    // - count: равный 0 потому что элементов нема
    // - capacity: равный 4
    }

    // Деструктор

    // Добавить элемент в конец очереди
    
    // Удалить первый элемент
    

    // Получить первый элемент
    
    // Проверить, пуста ли очередь
   

    // Количество элементов
   
};
```

---

##  `Deque` — двусторонняя очередь на массиве


```cpp
#include <iostream>
#include <stdexcept>
#include <cstddef>



class Deque {
private:
     // Массив
    // Индекс первого элемента
    // Индекс ПОСЛЕ последнего элемента
    // Количество элементов
    // Размер массива

    
public:
    Deque() {
      // - data выделяется массив из 8 целых чисел
      // - head и tail устанавливаются в середину массива 
      //   чтобы было место для добавления как в начало, так и в конец.
      // - count равный 0 - дек пустой :(
      // - capacity 8 
    }

    // Деконструктор

    //Добавление числа в начало дека


    //Добавление числа в конец дека

    //Удаление первого элемента

    //Удаление последнего элемента

    // Возвращение значения первого элемента

    // Возвращение значения последнего элемента

    // Возвращение количества элементов

    // Проверочка на пустоту

    
};
```

---

##  `BinarySearchTree` — дерево

```cpp
#include <iostream>
#include <stdexcept>
#include <cstddef>

class BinarySearchTree {
private:
    // Один узел дерева
    struct Node {
        // Число в узле
        / Левый ребёнок (меньше)
        // Правый ребёнок (больше)
        
        // Конструктор узла
    };

    // Корень дерева
     // Сколько всего узлов

    // Рекурсивное удаление всего дерева
   

    // Рекурсивный поиск
    
    // Рекурсивная вставка
    

    // Рекурсивный обход (лево -> корень -> право)
    

public:
    // Конструктор: создаёт пустое дерево
    BinarySearchTree() {
         // указатель на самый верхний узел дерева,
        // счётчик, который хранит, сколько всего узлов 
    }

    // Деструктор: удаляет всё дерево
    

    // Добавить число (игнорирует дубликаты)
   

    // Есть ли число в дереве?
  

    // Заполнить массив отсортированными числами
    // Массив должен быть размером не меньше size()
    
    // Пусто ли дерево?
   

    // Сколько узлов?
    
};
```
## Так же показать использование и при сдаче рассказать про свой код ;)
